## 第十三章 函数
#### 13.1.1 拷贝构造函数
##### 拷贝初始化
当使用直接初始化时，我们实际上要求编译器使用普通的函数匹配来选择与我们参数最匹配的构造函数。当我们使用拷贝初始化(copy initialization)时，我们要求编译器将右边运算对象拷贝到正在创建的对象中，如果需要的话还要进行类型转换。

拷贝初始化不仅在我们用`=`定义变量时会发生，在下列情况下也会发生
* 将一个对象作为实参传递给一个非引用类型的形参
* 从一个返回类型为非引用类型的函数返回一个对象
* 用花括号列表初始化一个数组中的元素或一个聚合类的成员

某些类类型还会对他们所分配的对象使用拷贝初始化。e.g. 当我们初始化标准库容器或者调用其`insert/push`成员时，容器会对其元素进行拷贝初始化。
##### 参数和返回值
在函数调用过程中，具有非引用类型的参数要进行拷贝初始化(实参->拷贝初始化->形参)。当一个函数具有非引用的返回类型时，返回值用于拷贝初始化调用方的结果。
> 拷贝构造函数被用来初始化非引用类类型参数， 这一个特性解释了为什么拷贝构造函数自身形参必须是引用类型。如果其参数不是引用类型，则调用永远不会成功——为了调用拷贝构造函数，我们必须用实参拷贝构造形参，但这本身又需要调用拷贝构造函数。先有鸡，还是先有蛋。

##### 拷贝初始化的限制
无论`vector<int>`接受单一大小参数的构造函数不是`explicit`的，`vector<int> v1(10)`都是正确的初始化方法，调用 **直接初始化** 。
* 如果`vector<int>`接受单一大小参数的构造函数是`explicit`
  ```cpp
  vector<int> v1(10);   //正确：直接初始化
  vector<int> v2 = 10;  //错误：无法隐式的将字面值常量10初始化为临时vector<int>，进而无法用临时vector<int>拷贝初始化v2
  ```
* 如果`vector<int>`接受单一大小参数的构造函数不是`explicit`
  ```cpp
  vector<int> v1(10);   //正确：直接初始化
  vector<int> v2 = 10;  //正确：隐式的将字面值常量10初始化为临时vector<int>，进而用临时vector<int>拷贝初始化v2
  ```

#### 13.1.2 拷贝赋值运算符
类可以控制其对象如何赋值：

```cpp
Sales_data trans, accum;
trans = accum;          //使用Sales_data的拷贝赋值运算符
```
##### 重载赋值运算符
**重载运算符** (overloaded operator)本质上是函数，其名字由`operator`关键字后接表示要定义的运算符符号组成。因此，赋值运算符就是一个名为`operator=`的函数。类似于任何其他函数，运算符函数也有一个返回类型和参数列表。

重载运算符的参数表示运算符的运算对象。
> 某些运算符，包括赋值运算符，必须定义为成员函数。如果一个运算符是一个成员函数，其左侧运算对象就绑定到隐式的`this`参数。

拷贝赋值运算符接受一个与其所在类相同类型的参数：
```cpp
class Foo {
public:
  Foo& operator=(const Foo&); //赋值运算符
};
```

#### 13.1.3 析构函数
构造函数初始化对象的非`static`数据成员，析构函数销毁对象的非`static`数据成员。
##### 析构函数完成什么工作
构造函数和析构函数都有一个初始化部分和一个函数体。不同的是：
* 在构造函数中，成员的初始化是在函数体执行之前完成，且按照类中出现的顺序进行初始化
* 在析构函数中，首先执行函数体(类设计者希望执行的任何收尾工作，e.g. 释放对象在生存期分配的所有资源)，然后执行初始化部分(隐式地销毁成员),按初始化顺序的逆序销毁。

> 成员销毁时发生什么完全依赖于成员类型。class类型成员执行成员自己的析构函数；内置类型没有析构函数，所以不需要做什么。

#### 13.1.5 使用=default
我们只能对具有合成版本的成员函数使用`=default`，即默认构造函数，拷贝控制成员(拷贝构造函数，拷贝赋值运算符，析构函数)。
#### 13.1.6 阻止拷贝
虽然大多数类应该定义拷贝构造函数和拷贝赋值运算符，但对某些类来说，这些操作没有合理的意义。在此情况下，定义类时必须采用某种机制阻止拷贝或赋值。e.g. `iostream`类阻止了拷贝，以避免多个对象写入或读取相同的`IO`缓冲。
##### 定义删除的函数
在新标准下，我们可以通过将拷贝构造函数和拷贝赋值运行符定义为 **删除的函数** (deleted function)来阻止拷贝。删除的函数是这样一种函数：我们虽然声明了它们，但是不能以任何方式使用它们。在函数的参数列表后面加上`=delete`来指出我们希望将它定义为删除的：
```cpp
struct NoCopy {
  NoCopy() = default;                         //使用合成的默认构造函数
  NoCopy(const NoCopy&) = delete;             //阻止拷贝
  NoCopy& operator=(const NoCopy&) = delete;  //阻止赋值
  ~NoCopy() = default;                        //使用合成的析构函数
};
```
##### 析构函数不能是删除的成员
##### 合成的拷贝控制成员可能是删除的(To be more familiar)
本质上，如果一个类有数据成员不能默认构造、拷贝、复制或销毁，则对应的成员函数将被定义为删除的。如果没有这条规则，我们可能会创建出无法销毁的对象。
##### private拷贝控制
在新标准发布前，类是通过将其拷贝构造函数和拷贝赋值运算符声明为`private`来阻止拷贝。

#### 13.2 拷贝控制和资源管理
##### 13.2.1 行为像值的类
为了提供类值的行为，对于类管理的资源，每个对象都应该拥有一份自己的拷贝。这意味着对于`ps`指向的`string`，每个`HasPtr`对象都必须有自己的拷贝。为此，`HasPtr`需要
* 定义一个拷贝构造函数，完成`string`的拷贝，而不是拷贝指针
* 定义一个析构函数来释放`string`
* 定义一个拷贝赋值运算符来释放对象当前的`string`，并从右侧运算对象拷贝`string`
```cpp
class HasPtr {
public:
  HasPtr(const std::string &s = std::string()) :
      ps(new std::string(s)), i(0) {}
  HasPtr(const HasPtr &p) :
      ps(new std::string(*p.ps)), i(p.i) {}
  HasPtr& operator=(const HasPtr &);
  ~HasPtr() {delete ps;}
private:
  std::string *ps;
  int i;
};
```
######
