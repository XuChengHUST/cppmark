## 第十三章 函数
#### 13.1.1 拷贝构造函数
##### 拷贝初始化
当使用直接初始化时，我们实际上要求编译器使用普通的函数匹配来选择与我们参数最匹配的构造函数。当我们使用拷贝初始化(copy initialization)时，我们要求编译器将右边运算对象拷贝到正在创建的对象中，如果需要的话还要进行类型转换。

拷贝初始化不仅在我们用`=`定义变量时会发生，在下列情况下也会发生
* 将一个对象作为实参传递给一个非引用类型的形参
* 从一个返回类型为非引用类型的函数返回一个对象
* 用花括号列表初始化一个数组中的元素或一个聚合类的成员

某些类类型还会对他们所分配的对象使用拷贝初始化。e.g. 当我们初始化标准库容器或者调用其`insert/push`成员时，容器会对其元素进行拷贝初始化。
##### 参数和返回值
在函数调用过程中，具有非引用类型的参数要进行拷贝初始化(实参->拷贝初始化->形参)。当一个函数具有非引用的返回类型时，返回值用于拷贝初始化调用方的结果。
> 拷贝构造函数被用来初始化非引用类类型参数， 这一个特性解释了为什么拷贝构造函数自身形参必须是引用类型。如果其参数不是引用类型，则调用永远不会成功——为了调用拷贝构造函数，我们必须用实参拷贝构造形参，但这本身又需要调用拷贝构造函数。先有鸡，还是先有蛋。

##### 拷贝初始化的限制
无论`vector<int>`接受单一大小参数的构造函数不是`explicit`的，`vector<int> v1(10)`都是正确的初始化方法，调用 **直接初始化** 。
* 如果`vector<int>`接受单一大小参数的构造函数是`explicit`
  ```cpp
  vector<int> v1(10);   //正确：直接初始化
  vector<int> v2 = 10;  //错误：无法隐式的将字面值常量10初始化为临时vector<int>，进而无法用临时vector<int>拷贝初始化v2
  ```
* 如果`vector<int>`接受单一大小参数的构造函数不是`explicit`
  ```cpp
  vector<int> v1(10);   //正确：直接初始化
  vector<int> v2 = 10;  //正确：隐式的将字面值常量10初始化为临时vector<int>，进而用临时vector<int>拷贝初始化v2
  ```

#### 13.1.2 拷贝赋值运算符
类可以控制其对象如何赋值：

```cpp
Sales_data trans, accum;
trans = accum;          //使用Sales_data的拷贝赋值运算符
```
##### 重载赋值运算符
**重载运算符** (overloaded operator)本质上是函数，其名字由`operator`关键字后接表示要定义的运算符符号组成。因此，赋值运算符就是一个名为`operator=`的函数。类似于任何其他函数，运算符函数也有一个返回类型和参数列表。

重载运算符的参数表示运算符的运算对象。
> 某些运算符，包括赋值运算符，必须定义为成员函数。如果一个运算符是一个成员函数，其左侧运算对象就绑定到隐式的`this`参数。

拷贝赋值运算符接受一个与其所在类相同类型的参数：
```cpp
class Foo {
public:
  Foo& operator=(const Foo&); //赋值运算符
};
```

#### 13.1.3 析构函数
构造函数初始化对象的非`static`数据成员，析构函数销毁对象的非`static`数据成员。
##### 析构函数完成什么工作
构造函数和析构函数都有一个初始化部分和一个函数体。不同的是：
* 在构造函数中，成员的初始化是在函数体执行之前完成，且按照类中出现的顺序进行初始化
* 在析构函数中，首先执行函数体(类设计者希望执行的任何收尾工作，e.g. 释放对象在生存期分配的所有资源)，然后执行初始化部分(隐式地销毁成员),按初始化顺序的逆序销毁。

> 成员销毁时发生什么完全依赖于成员类型。class类型成员执行成员自己的析构函数；内置类型没有析构函数，所以不需要做什么。

#### 13.1.5 使用=default
我们只能对具有合成版本的成员函数使用`=default`，即默认构造函数，拷贝控制成员(拷贝构造函数，拷贝赋值运算符，析构函数)。
#### 13.1.6 阻止拷贝
虽然大多数类应该定义拷贝构造函数和拷贝赋值运算符，但对某些类来说，这些操作没有合理的意义。在此情况下，定义类时必须采用某种机制阻止拷贝或赋值。e.g. `iostream`类阻止了拷贝，以避免多个对象写入或读取相同的`IO`缓冲。
##### 定义删除的函数
在新标准下，我们可以通过将拷贝构造函数和拷贝赋值运行符定义为 **删除的函数** (deleted function)来阻止拷贝。删除的函数是这样一种函数：我们虽然声明了它们，但是不能以任何方式使用它们。在函数的参数列表后面加上`=delete`来指出我们希望将它定义为删除的：
```cpp
struct NoCopy {
  NoCopy() = default;                         //使用合成的默认构造函数
  NoCopy(const NoCopy&) = delete;             //阻止拷贝
  NoCopy& operator=(const NoCopy&) = delete;  //阻止赋值
  ~NoCopy() = default;                        //使用合成的析构函数
};
```
##### 析构函数不能是删除的成员
##### 合成的拷贝控制成员可能是删除的(To be more familiar)
本质上，如果一个类有数据成员不能默认构造、拷贝、复制或销毁，则对应的成员函数将被定义为删除的。如果没有这条规则，我们可能会创建出无法销毁的对象。
##### private拷贝控制
在新标准发布前，类是通过将其拷贝构造函数和拷贝赋值运算符声明为`private`来阻止拷贝。

#### 13.2 拷贝控制和资源管理
##### 13.2.1 行为像值的类
为了提供类值的行为，对于类管理的资源，每个对象都应该拥有一份自己的拷贝。这意味着对于`ps`指向的`string`，每个`HasPtr`对象都必须有自己的拷贝。为此，`HasPtr`需要
* 定义一个拷贝构造函数，完成`string`的拷贝，而不是拷贝指针
* 定义一个析构函数来释放`string`
* 定义一个拷贝赋值运算符来释放对象当前的`string`，并从右侧运算对象拷贝`string`

```cpp
class HasPtr {
public:
  HasPtr(const std::string &s = std::string()) :
      ps(new std::string(s)), i(0) {}
  HasPtr(const HasPtr &p) :
      ps(new std::string(*p.ps)), i(p.i) {}
  HasPtr& operator=(const HasPtr &);
  ~HasPtr() {delete ps;}
private:
  std::string *ps;
  int i;
};
```
###### 类值拷贝赋值运算符
赋值运算符通常组合了析构函数和构造函数的操作。类似析构函数，赋值操作会销毁左侧运算对象的资源；类似拷贝构造函数，赋值操作会从右侧运算对象拷贝数据。但是，非常重要的一点是，即使将一个对象赋予它自身，也需要保持正确。而且，如果可能，它还应该是异常安全的——当异常发生时，能讲左侧运算对象置于一个有意义的状态。
```cpp
HasPtr& operator=(const HasPtr &rhs) {
  // 拷贝右侧对象，用于处理自赋值情况
  std::string (*newp) = new string(*rhs.ps);
  // 销毁左侧运算对象的资源
  delete ps;
  // 从右侧运算对象拷贝数据到本对象，newp并不是rhs.ps
  ps = newp;
  i = rhs.i;
  // 返回本对象
  return (*this);
}
```

> 当编写赋值运算符时，有两点需要记住
* 如果将一个对象赋予给自身，赋值运算符必须能正确工作
* 大多数赋值运算符组合了析构函数和拷贝构造函数的工作
当编写一个赋值运算符时，一个好的模式是先将右侧运算对象拷贝到一个局部临时对象中。当拷贝完成后，销毁左侧运算对象的现有成员就是安全的了。一旦左侧运算对象的资源被销毁，就只剩下将数据从临时对象拷贝到左侧运算对象的成员中了。

#### 13.2.2 定义行为像指针的类
引用计数：
* 除了初始化对象外，每个构造函数(拷贝构造函数除外)还要创建一个引用计数，用来记录有多少对象与正在创建的对象共享状态。
* 拷贝构造函数不分配新的计数器，而是拷贝给定对象的数据成员，包括计数器。拷贝构造函数递增共享的计数器，指出给定对象的状态又被一个新对象共享了。
* 析构函数递减计数器，如果计数器变为0，则析构函数释放状态。
* 拷贝赋值运算符递增右侧运算对象的计算器，递减左侧运算对象的计数器。如果左侧运算对象的计数器变为0，拷贝赋值运算符就必须销毁状态。

计数器保存在动态内存中，当创建一个对象时，应分配一个新的计数器。当拷贝或赋值对象时，我们拷贝指向计数器的指针。使用这种方法，副本和原对象都会指向相同的计数器。

##### 定义一个使用引用计数的类
```cpp
class HasPtr {
public:
  HasPtr(const std::string &s = std::string()) :
    ps(new std::sting(s)), i(0), use(new std::size_t(1)) {}
  HasPtr(const HasPtr &p) :
    ps(p.ps), i(p.i), use(p.use) {++* use;}
  HasPtr& operator=(const HasPtr&);
  ~HasPtr();
private:
  std::string *ps;
  int i;
  std::size_t *use;
}
```

析构函数应首先递减引用计数，指出共享`string`的对象少了一个。如果计数器变为0，则析构函数释放`ps`和`use`指向的内存。
```cpp
HasPtr::~HasPtr() {
  if(--*use == 0) {
    delete ps;
    delete use;
  }
}
```
拷贝赋值运算符必须递增右侧运算对象的引用计数，并递减左侧运算对象的引用计数，在必要时释放使用的内存。而且，必须处理自赋值——通过先递增`rhs`中的计数，然后递减左侧运算对象的计数来实现。这样，当两个对象相同时，在我们检查`ps`及`use`是否应该释放前，计数器就已经被递增过了。
```cpp
HasPtr& HasPtr::operator=(const HasPtr &rhs) {
  ++* rhs.ps;       // 递增右侧运算对象的引用计数
  if(--*use == 0) { // 递减本对象的引用计数
    delete ps;      // 如果没有其他对象引用
    delete use;     // 释放本对象分配的成员
  }
  ps = rhs.ps;      // 本对象指针成员指向rhs指针成员
  i = rhs.i;
  use = rhs.use;
  return (*this);
}
```
