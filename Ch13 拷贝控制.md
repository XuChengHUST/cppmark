## 第十三章 函数
#### 13.1.1 拷贝构造函数
##### 拷贝初始化
当使用直接初始化时，我们实际上要求编译器使用普通的函数匹配来选择与我们参数最匹配的构造函数。当我们使用拷贝初始化(copy initialization)时，我们要求编译器将右边运算对象拷贝到正在创建的对象中，如果需要的话还要进行类型转换。

拷贝初始化不仅在我们用`=`定义变量时会发生，在下列情况下也会发生
* 将一个对象作为实参传递给一个非引用类型的形参
* 从一个返回类型为非引用类型的函数返回一个对象
* 用花括号列表初始化一个数组中的元素或一个聚合类的成员

某些类类型还会对他们所分配的对象使用拷贝初始化。e.g. 当我们初始化标准库容器或者调用其`insert/push`成员时，容器会对其元素进行拷贝初始化。
##### 参数和返回值
在函数调用过程中，具有非引用类型的参数要进行拷贝初始化(实参->拷贝初始化->形参)。当一个函数具有非引用的返回类型时，返回值用于拷贝初始化调用方的结果。
> 拷贝构造函数被用来初始化非引用类类型参数， 这一个特性解释了为什么拷贝构造函数自身形参必须是引用类型。如果其参数不是引用类型，则调用永远不会成功——为了调用拷贝构造函数，我们必须用实参拷贝构造形参，但这本身又需要调用拷贝构造函数。先有鸡，还是先有蛋。

##### 拷贝初始化的限制
无论`vector<int>`接受单一大小参数的构造函数不是`explicit`的，`vector<int> v1(10)`都是正确的初始化方法，调用 **直接初始化** 。
* 如果`vector<int>`接受单一大小参数的构造函数，是`explicit`
  ```cpp
  vector<int> v1(10);   //正确：直接初始化
  vector<int> v2 = 10;  //错误：无法隐式的将字面值常量10初始化为临时vector<int>，进而无法用临时vector<int>拷贝初始化v2
  ```
* 如果`vector<int>`接受单一大小参数的构造函数，不是`explicit`
  ```cpp
  vector<int> v1(10);   //正确：直接初始化
  vector<int> v2 = 10;  //正确：隐式的将字面值常量10初始化为临时vector<int>，进而用临时vector<int>拷贝初始化v2
  ```

#### 13.1.2 拷贝赋值运算符
类可以控制其对象如何赋值：

```cpp
Sales_data trans, accum;
trans = accum;          //使用Sales_data的拷贝赋值运算符
```
