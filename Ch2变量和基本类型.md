## 第二章 变量类型和基本类型
### 2.2 变量
**变量** 提供了一个具名的、可供程序操作的存储空间。C++中每个变量都有其数据类型，数据类型决定着变量所占内存空间的大小和布局方式、该空间能存储的值的范围，以及变量能参与的运算。
#### 2.2.1 变量定义
变量定义的基本形式是：首先是 **类型说明符** (type specifier)，随后紧跟由一个或多个变量名组成的列表，其中变量名以逗号分隔，最后以分号结束。
##### 初始值
当对象在创建时获得了一个特定的值，我们说这个对象被 **初始化** (initialized)了。
> 初始化不是赋值，初始化的含义是创建变量时赋予了其一个初始值，而赋值的含义是把对象的当前值擦除，而以一个新值来替代。

#### 2.2.2 变量声明和定义的关系
为了支持分离式编译 (seperate compliation)，C++将声明和定义区分开。**声明** (declaration)使得名字为程序所知，一个文件如果想使用别处定义的名字则必须包含对那个名字的声明。而 **定义** (definition)负责创建与名字关联的实体。

如果想声明一个变量而非定义它，就在变量名前添加关键字`extern`，而不要显式地初始化变量
```cpp
extern int i;   // 声明i而非定义i
int j;          // 声明并定义j
```
任何包含了显式初始化的声明即成为定义。我们能给由`extern`关键字标记的变量赋一个初始值，但这么做也就抵消了`extern`的作用。`extern`语句如果包含初始值就不再是声明了，变成定义了。
```cpp
extern double pi = 3.1416   // 定义
```
> 在函数体内部试图初始化一个`extern`关键字标记的变量，将引发错误。

##### 列表初始化
以下4条语句是初始化语句
```cpp
int units_sold = 0;
int units_sold = {0};
int units_sold{0};
int units_sold(0);
```
作为C++11新标准的一部分，用花括号来初始化变量的形式被称为 **初始化列表** (list initialization)。它用于内置类型的变量时：如果我们使用列表初始化，且初始化存在丢失信息的风险，则编译器会报错。
##### 默认初始化
如果定义变量时没有指定初始值，则变量被 **默认初始化** (default initialized)。此时变量被赋予了“默认值”。默认值是什么由变量类型决定，同时定义变量的位置也会有影响。

如果内置类型的变量被默认初始化，它的值由定义的位置决定。
* 定义于任何函数体之外的变量被初始化为0
* 定义在函数体内部的内置类型将不被初始化 (uninitialized)。一个未被初始化的内置类型变量的值是未定义的 (undefined)。如果试图拷贝或者以其他形式访问此变量将引发错误。

各个类各自决定其初始化的方式。

#### 2.2.3 标识符
##### 变量命名规范
* 标识符(identifier)要能体现实际含义
* 变量名一般用小写字母
* 用户自定义的类名一般以大写字母开头
* 如果标识符由多个单词组成，则单词间应有明显区分。

### 2.3 复合类型
一条声明语句由一个 **基本数据类型** (base type) 和紧随其后的一个 **声明符** (declarator)列表组成。*每个声明符命名了一个变量* 并 *指定该变量为与基本数据类型有关的某种类型*。
#### 2.3.1 引用
**引用** (reference)为对象起了另外一个名字，引用类型引用(refers to)另外一种类型。通过将声明符写成 &d 的形式来定义引用类型，其中d是声明的变量名。
```C++
int ival = 1024;    
int &refVal = ival; //refVal指向ival
int &refVal2;       //error: 引用必须初始化
```
一般在初始化变量时，初始值会被拷贝到新建的对象中。然而定义引用时，程序把引用和它的初始值绑定在一起，而不是将初始值拷贝给引用。一旦初始化完成，引用将和它的初始值对象一直绑定在一起。因为无法令引用重新绑定到另一个对象，因此引用必须初始化。

> 1. 引用并非对象，相反的，它只是为一个已经存在的对象所起的另外一个名字。
2. 为引用赋值，实际上是把值赋给了与引用绑定的对象。
3. 获取引用的值，实际上是获取了与引用绑定的对象的值
4. 以引用作为初始值，实际上是以引用绑定的对象作为初始值。
5. 因为引用本身不是对象，所以不能定义引用的引用。
6. 引用只能绑定到对象上，而不能与字面值或某个表达式的计算结果绑定到一起。

```C++
int &refVal4 = 10; //error: 引用类型的初始值必须是一个对象
```
### 2.4 const限定符
const对象一旦创建后其值就不能再改变，所以const对象必须初始化，初始值可以是任意复杂的表达式。

> 如果想在多个文件之间共享const对象，必须在变量的定义之前添加extern关键字。

#### 2.4.1 const引用
可以将引用绑定(bind)到const对象上，我们称之为 **对常量的引用**(reference to const)。与普通引用不同的是，对常量的引用不能被用作修改它说绑定的对象
```cpp
const int ci = 1024;
const int &r1 = ci;   //true: r1是对const int的引用
int &r_2 = 42;        //error: r_2是对int的引用，不能绑定到字面值
const int &r2 = 42;   //true: 初始化const引用时允许用任意表达式作为初始值，只要该表达式的结果能转换成引用的类型即可。

r1 = 42;              
//error: 为引用赋值实际上是把值赋给了与引用绑定的对象
//此处试图讲字面值42赋给ci(const int类型)
//const限定的int对象ci必须要被初始化，但之后无法修改。
int &r3 = ci;         //error: int引用无法绑定到const int对象
```

#### 2.6.1 定义类数据成员
##### 类数据成员
C++11新标准规定，可以为数据成员提供一个 **类内初始值** (in-class initialization)。创建对象时，类内初始值将用于初始化数据成员。没有初始值的成员将被默认初始化。
```cpp
struct Sales_data {
  std::string bookNo;
  unsigned units_sold = 0;
  double revenue = 0.0;
};
```
